{"entries":[{"timestamp":1734604496025,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Vedirect {\n    private static final int HEX = 0;\n    private static final int WAIT_HEADER = 1;\n    private static final int IN_KEY = 2;\n    private static final int IN_VALUE = 3;\n    private static final int IN_CHECKSUM = 4;\n\n    private String serialport;\n    private int timeout;\n    private InputStream input;\n    private OutputStream output;\n    private byte header1;\n    private byte header2;\n    private byte hexmarker;\n    private byte delimiter;\n    private String key;\n    private String value;\n    private int bytes_sum;\n    private int state;\n    private Map<String, String> dict;\n\n    public Vedirect(String serialport, int timeout) {\n        this.serialport = serialport;\n        this.timeout = timeout;\n        this.input = null;\n        this.output = null;\n        this.header1 = '\\r';\n        this.header2 = '\\n';\n        this.hexmarker = ':';\n        this.delimiter = '\\t';\n        this.key = \"\";\n        this.value = \"\";\n        this.bytes_sum = 0;\n        this.state = WAIT_HEADER;\n        this.dict = new HashMap<>();\n    }\n\n    public void connect() throws IOException {\n        // Open the serial port and initialize input/output streams\n        // implementation omitted for brevity\n    }\n\n    public void disconnect() throws IOException {\n        // Close the serial port and release resources\n        // implementation omitted for brevity\n    }\n\n    public void readDataSingle() throws IOException {\n        while (true) {\n            int data = input.read();\n            if (data == -1) {\n                // End of stream reached, break the loop\n                break;\n            }\n            byte singleByte = (byte) data;\n            Map<String, String> packet = input(singleByte);\n            if (packet != null) {\n                // Packet received, do something with it\n                // implementation omitted for brevity\n                break;\n            }\n        }\n    }\n\n    public void readDataCallback(CallbackFunction callbackFunction) throws IOException {\n        while (true) {\n            int data = input.read();\n            if (data == -1) {\n                // End of stream reached, break the loop\n                break;\n            }\n            byte singleByte = (byte) data;\n            Map<String, String> packet = input(singleByte);\n            if (packet != null) {\n                // Packet received, invoke the callback function\n                callbackFunction.callback(packet);\n            }\n        }\n    }\n\n    private Map<String, String> input(byte inputByte) {\n        if (inputByte == hexmarker && state != IN_CHECKSUM) {\n            state = HEX;\n        }\n\n        if (state == WAIT_HEADER) {\n            bytes_sum += inputByte;\n            if (inputByte == header1) {\n                state = WAIT_HEADER;\n            } else if (inputByte == header2) {\n                state = IN_KEY;\n            }\n            return null;\n        } else if (state == IN_KEY) {\n            bytes_sum += inputByte;\n            if (inputByte == delimiter) {\n                if (key.equals(\"Checksum\")) {\n                    state = IN_CHECKSUM;\n                } else {\n                    state = IN_VALUE;\n                }\n            } else {\n                key += (char) inputByte;\n            }\n            return null;\n        } else if (state == IN_VALUE) {\n            bytes_sum += inputByte;\n            if (inputByte == header1) {\n                state = WAIT_HEADER;\n                dict.put(key, value);\n                key = \"\";\n                value = \"\";\n            } else {\n                value += (char) inputByte;\n            }\n            return null;\n        } else if (state == IN_CHECKSUM) {\n            bytes_sum += inputByte;\n            key = \"\";\n            value = \"\";\n            state = \"\"\n            }\n            }\n            }\n            }\n            }\n        "],[1,"\n"]],"start1":0,"start2":0,"length1":3995,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":228,"start2":228,"length1":32,"length2":31}]}]},{"timestamp":1734604567381,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Vedirect {\n    private static final int HEX = 0;\n    private static final int WAIT_HEADER = 1;\n    private static final int IN_KEY = 2;\n    private static final int IN_VALUE = 3;\n    private static final int IN_CHECKSUM = 4;\n\n    private String serialport;\n    private int timeout;\n    private InputStream input;\n    private OutputStream output;\n    private byte header1;\n    private byte header2;\n    private byte hexmarker;\n    private byte delimiter;\n    private String key;\n    private String value;\n    private int bytes_sum;\n    private int state;\n    private Map<String, String> dict;\n\n    public Vedirect(String serialport, int timeout) {\n        this.serialport = serialport;\n        this.timeout = timeout;\n        this.input = null;\n        this.output = null;\n        this.header1 = '\\r';\n        this.header2 = '\\n';\n        this.hexmarker = ':';\n        this.delimiter = '\\t';\n        this.key = \"\";\n        this.value = \"\";\n        this.bytes_sum = 0;\n        this.state = WAIT_HEADER;\n        this.dict = new HashMap<>();\n    }\n\n    public void connect() throws IOException {\n        // Open the serial port and initialize input/output streams\n        // implementation omitted for brevity\n    }\n\n    public void disconnect() throws IOException {\n        // Close the serial port and release resources\n        // implementation omitted for brevity\n    }\n\n    public void readDataSingle() throws IOException {\n        while (true) {\n            int data = input.read();\n            if (data == -1) {\n                // End of stream reached, break the loop\n                break;\n            }\n            byte singleByte = (byte) data;\n            Map<String, String> packet = input(singleByte);\n            if (packet != null) {\n                // Packet received, do something with it\n                // implementation omitted for brevity\n                break;\n            }\n        }\n    }\n\n    public void readDataCallback(CallbackFunction callbackFunction) throws IOException {\n        while (true) {\n            int data = input.read();\n            if (data == -1) {\n                // End of stream reached, break the loop\n                break;\n            }\n            byte singleByte = (byte) data;\n            Map<String, String> packet = input(singleByte);\n            if (packet != null) {\n                // Packet received, invoke the callback function\n                callbackFunction.callback(packet);\n            }\n        }\n    }\n\n    private Map<String, String> input(byte inputByte) {\n        if (inputByte == hexmarker && state != IN_CHECKSUM) {\n            state = HEX;\n        }\n\n        if (state == WAIT_HEADER) {\n            bytes_sum += inputByte;\n            if (inputByte == header1) {\n                state = WAIT_HEADER;\n            } else if (inputByte == header2) {\n                state = IN_KEY;\n            }\n            return null;\n        } else if (state == IN_KEY) {\n            bytes_sum += inputByte;\n            if (inputByte == delimiter) {\n                if (key.equals(\"Checksum\")) {\n                    state = IN_CHECKSUM;\n                } else {\n                    state = IN_VALUE;\n                }\n            } else {\n                key += (char) inputByte;\n            }\n            return null;\n        } else if (state == IN_VALUE) {\n            bytes_sum += inputByte;\n            if (inputByte == header1) {\n                state = WAIT_HEADER;\n                dict.put(key, value);\n                key = \"\";\n                value = \"\";\n            } else {\n                value += (char) inputByte;\n            }\n            return null;\n        } else if (state == IN_CHECKSUM) {\n            bytes_sum += inputByte;\n            key = \"\";\n            value = \"\";\n            state = \"\"\n            }\n            }\n            }\n            }\n            }"],[0,"\n       "]],"start1":0,"start2":0,"length1":8,"length2":3994}]}]},{"timestamp":1734606021786,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"main.py\""],[0,"\n   "]],"start1":215,"start2":215,"length1":27,"length2":8}]},{"type":"added","filename":"main.py","value":""}]},{"timestamp":1734606024081,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\""],[-1," id=\"W)?O2O%+J8Z`I/p+$xDk\""],[0," x=\""]],"start1":100,"start2":100,"length1":34,"length2":8},{"diffs":[[0,"ver\""],[-1," id=\"SlY~(Sa{U9Kcwnki3g?|\""],[0," x=\""]],"start1":151,"start2":151,"length1":34,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n"],[1,"        "]],"start1":0,"start2":0,"length1":1,"length2":9}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"Test"],[-1," good VE code"],[0,"\",\n "]],"start1":15,"start2":15,"length1":21,"length2":8},{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":242,"start2":242,"length1":52,"length2":8},{"diffs":[[0,"itor\": \""],[-1,"py"],[1,"ts"],[0,"prj\"\n}\n"]],"start1":262,"start2":262,"length1":17,"length2":17}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[-1,"#include \"vedirect_parser.h\"\n\n#include <cstring>\n\nnamespace VEDirect {\n\nbool FieldParser_mV(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() / 1000;  // mV to V\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_permille(const String value,\n                          ObservableValue<float>* observable) {\n  float val_ = value.toFloat() / 1000;  // permille to ratio\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_W(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat();\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_mA(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() / 1000;  // mA to A\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_mAh(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() / 1000 * 3600;  // mAh to Coulomb\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_degC(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() + 273.15;  // degC to K\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_minutes(const String value,\n                         ObservableValue<float>* observable) {\n  float val_ = value.toFloat() * 60;  // minutes to seconds\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_seconds(const String value,\n                         ObservableValue<float>* observable) {\n  float val_ = value.toFloat();  // minutes to seconds\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_kWh(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() * 0.01 * 3.6e6;  // 0.01 kWh to J\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_Vac(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() * 0.01;  // 0.01 V to V\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_Iac(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat() * 0.1;  // 0.1 A to A\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_VA(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toFloat();\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_int(const String value, ObservableValue<float>* observable) {\n  float val_ = value.toInt();\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_int(const String value, ObservableValue<int>* observable) {\n  float val_ = value.toInt();\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_ONOFF(const String value, ObservableValue<bool>* observable) {\n  bool ok = false;\n  bool val_;\n\n  String val_upper = value;\n  val_upper.toUpperCase();\n\n  if (val_upper == \"ON\") {\n    val_ = true;\n    ok = true;\n  } else if (val_upper == \"OFF\") {\n    val_ = false;\n    ok = true;\n  }\n  if (ok) {\n    observable->set(val_);\n  }\n  return ok;\n}\n\nbool FieldParser_uint16(const String value, ObservableValue<int>* observable) {\n  float val_ = value.toInt();\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_uint24(const String value, ObservableValue<int>* observable) {\n  float val_ = value.toInt();\n  observable->set(val_);\n  return true;\n}\n\nbool FieldParser_str(const String value, ObservableValue<String>* observable) {\n  observable->set(value);\n  return true;\n}\n\nParser::Parser() {\n  add_all_field_parsers();\n  current_state = &Parser::state_start;\n}\n\nvoid Parser::add_all_field_parsers() {\n  field_parsers[\"V\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.channel_1_battery_voltage));\n  };\n  field_parsers[\"V2\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.channel_2_battery_voltage));\n  };\n  field_parsers[\"V3\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.channel_3_battery_voltage));\n  };\n  field_parsers[\"VS\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.auxiliary_voltage));\n  };\n  field_parsers[\"VM\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.mid_point_voltage));\n  };\n  field_parsers[\"DM\"] = [this](const String value) -> bool {\n    return FieldParser_permille(value, &(this->data.mid_point_deviation));\n  };\n  field_parsers[\"VPV\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.panel_voltage));\n  };\n  field_parsers[\"PPV\"] = [this](const String value) -> bool {\n    return FieldParser_W(value, &(this->data.panel_power));\n  };\n  field_parsers[\"I\"] = [this](const String value) -> bool {\n    return FieldParser_mA(value, &(this->data.channel_1_battery_current));\n  };\n  field_parsers[\"I2\"] = [this](const String value) -> bool {\n    return FieldParser_mA(value, &(this->data.channel_2_battery_current));\n  };\n  field_parsers[\"I3\"] = [this](const String value) -> bool {\n    return FieldParser_mA(value, &(this->data.channel_3_battery_current));\n  };\n  field_parsers[\"IL\"] = [this](const String value) -> bool {\n    return FieldParser_mA(value, &(this->data.load_current));\n  };\n  field_parsers[\"LOAD\"] = [this](const String value) -> bool {\n    return FieldParser_ONOFF(value, &(this->data.load_output_state));\n  };\n  field_parsers[\"T\"] = [this](const String value) -> bool {\n    return FieldParser_degC(value, &(this->data.battery_temperature));\n  };\n  field_parsers[\"P\"] = [this](const String value) -> bool {\n    return FieldParser_W(value, &(this->data.instantaneous_power));\n  };\n  field_parsers[\"CE\"] = [this](const String value) -> bool {\n    return FieldParser_mAh(value, &(this->data.consumed_energy));\n  };\n  field_parsers[\"SOC\"] = [this](const String value) -> bool {\n    return FieldParser_permille(value, &(this->data.state_of_charge));\n  };\n  field_parsers[\"TTG\"] = [this](const String value) -> bool {\n    return FieldParser_minutes(value, &(this->data.time_to_go));\n  };\n  field_parsers[\"Alarm\"] = [this](const String value) -> bool {\n    return FieldParser_ONOFF(value, &(this->data.alarm_condition_active));\n  };\n  field_parsers[\"Relay\"] = [this](const String value) -> bool {\n    return FieldParser_ONOFF(value, &(this->data.relay_state));\n  };\n  field_parsers[\"AR\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.alarm_reason));\n  };\n  field_parsers[\"OR\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.off_reason));\n  };\n  field_parsers[\"H1\"] = [this](const String value) -> bool {\n    return FieldParser_mAh(value, &(this->data.depth_of_deepest_discharge));\n  };\n  field_parsers[\"H2\"] = [this](const String value) -> bool {\n    return FieldParser_mAh(value, &(this->data.depth_of_last_discharge));\n  };\n  field_parsers[\"H3\"] = [this](const String value) -> bool {\n    return FieldParser_mAh(value, &(this->data.depth_of_average_discharge));\n  };\n  field_parsers[\"H4\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.number_of_charge_cycles));\n  };\n  field_parsers[\"H5\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.number_of_full_discharges));\n  };\n  field_parsers[\"H6\"] = [this](const String value) -> bool {\n    return FieldParser_mAh(value, &(this->data.cumulative_energy_drawn));\n  };\n  field_parsers[\"H7\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.minimum_main_voltage));\n  };\n  field_parsers[\"H8\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.maximum_main_voltage));\n  };\n  field_parsers[\"H9\"] = [this](const String value) -> bool {\n    return FieldParser_seconds(value,\n                               &(this->data.seconds_since_last_full_charge));\n  };\n  field_parsers[\"H10\"] = [this](const String value) -> bool {\n    return FieldParser_int(value,\n                           &(this->data.number_of_automatic_synchronizations));\n  };\n  field_parsers[\"H11\"] = [this](const String value) -> bool {\n    return FieldParser_int(value,\n                           &(this->data.number_of_low_main_voltage_alarms));\n  };\n  field_parsers[\"H12\"] = [this](const String value) -> bool {\n    return FieldParser_int(value,\n                           &(this->data.number_of_high_main_voltage_alarms));\n  };\n  field_parsers[\"H13\"] = [this](const String value) -> bool {\n    return FieldParser_int(\n        value, &(this->data.number_of_low_auxiliary_voltage_alarms));\n  };\n  field_parsers[\"H14\"] = [this](const String value) -> bool {\n    return FieldParser_int(\n        value, &(this->data.number_of_high_auxiliary_voltage_alarms));\n  };\n  field_parsers[\"H15\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.minimum_auxiliary_voltage));\n  };\n  field_parsers[\"H16\"] = [this](const String value) -> bool {\n    return FieldParser_mV(value, &(this->data.maximum_auxiliary_voltage));\n  };\n  field_parsers[\"H17\"] = [this](const String value) -> bool {\n    return FieldParser_kWh(value, &(this->data.amount_of_discharged_energy));\n  };\n  field_parsers[\"H18\"] = [this](const String value) -> bool {\n    return FieldParser_kWh(value, &(this->data.amount_of_charged_energy));\n  };\n  field_parsers[\"H19\"] = [this](const String value) -> bool {\n    return FieldParser_kWh(value, &(this->data.yield_total));\n  };\n  field_parsers[\"H20\"] = [this](const String value) -> bool {\n    return FieldParser_kWh(value, &(this->data.yield_today));\n  };\n  field_parsers[\"H21\"] = [this](const String value) -> bool {\n    return FieldParser_W(value, &(this->data.maximum_power_today));\n  };\n  field_parsers[\"H22\"] = [this](const String value) -> bool {\n    return FieldParser_kWh(value, &(this->data.yield_yesterday));\n  };\n  field_parsers[\"H23\"] = [this](const String value) -> bool {\n    return FieldParser_W(value, &(this->data.maximum_power_yesterday));\n  };\n  field_parsers[\"ERR\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.error_code));\n  };\n  field_parsers[\"CS\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.state_of_operation));\n  };\n  field_parsers[\"BMV\"] = [this](const String value) -> bool {\n    return FieldParser_str(value, &(this->data.model_description));\n  };\n  field_parsers[\"FW\"] = [this](const String value) -> bool {\n    return FieldParser_uint16(value, &(this->data.firmware_version));\n  };\n  field_parsers[\"FWE\"] = [this](const String value) -> bool {\n    return FieldParser_uint24(value, &(this->data.firmware_version_24));\n  };\n  field_parsers[\"PID\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.product_id));\n  };\n  field_parsers[\"SER#\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.serial_number));\n  };\n  field_parsers[\"HSDS\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.day_sequence_number));\n  };\n  field_parsers[\"MODE\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.device_mode));\n  };\n  field_parsers[\"AC_OUT_V\"] = [this](const String value) -> bool {\n    return FieldParser_Vac(value, &(this->data.ac_output_voltage));\n  };\n  field_parsers[\"AC_OUT_I\"] = [this](const String value) -> bool {\n    return FieldParser_Iac(value, &(this->data.ac_output_current));\n  };\n  field_parsers[\"AC_OUT_S\"] = [this](const String value) -> bool {\n    return FieldParser_VA(value, &(this->data.ac_output_apparent_power));\n  };\n  field_parsers[\"WARN\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.warning_reason));\n  };\n  field_parsers[\"MPPT\"] = [this](const String value) -> bool {\n    return FieldParser_int(value, &(this->data.tracker_operation_mode));\n  };\n}\n\nvoid Parser::handle(int c) {\n  Serial.write(c);\n  checksum = (checksum + c) & 255;\n  (this->*(current_state))(c);\n}\n\nvoid Parser::state_start(char c) {\n  cur_offset = 0;\n  current_state = &Parser::state_label;\n  (this->*(current_state))(c);\n}\n\nvoid Parser::state_label(char c) {\n  if (c == '\\t') {\n    // done reading the label\n    label_buffer[cur_offset++] = 0;\n    current_state = &Parser::state_tab;\n    (this->*(current_state))(c);\n    return;\n  }\n  if (cur_offset == label_max_length) {\n    // read too much already\n    current_state = &Parser::state_error;\n    (this->*(current_state))(c);\n    return;\n  }\n  // process the next character of the label\n  label_buffer[cur_offset++] = c;\n}\n\nvoid Parser::state_tab(char c) {\n  cur_offset = 0;\n  if (strcmp(label_buffer, \"Checksum\") == 0) {\n    // the checksum byte needs special treatment\n    current_state = &Parser::state_checksum_value;\n  } else {\n    current_state = &Parser::state_value;\n  }\n  // we already know we're at a tab, so we can ingest it by doing nothing\n}\n\nvoid Parser::state_value(char c) {\n  if (c == 0x0d) {\n    // beginning of newline -- we got a complete field\n    value_buffer[cur_offset++] = 0;\n    current_state = &Parser::state_received_field;\n    (this->*(current_state))(c);\n    return;\n  }\n  if (cur_offset == value_max_length) {\n    // read too much already\n    current_state = &Parser::state_error;\n    (this->*(current_state))(c);\n    return;\n  }\n  // process the next character of the value\n  value_buffer[cur_offset++] = c;\n}\n\nvoid Parser::state_checksum_value(char c) {\n  debugD(\"Checksum: %d (%d) vs %d\", checksum, checksum % 256, c);\n  if (checksum == 0) {\n    // checksum matches, we've received the whole block\n    current_state = &Parser::state_received_block;\n    (this->*(current_state))(c);\n  } else {\n    // else the checksum didn't match\n    current_state = &Parser::state_newline;\n  }\n  checksum = 0;\n}\n\nvoid Parser::state_received_field(char c) {\n  debugD(\"Received field: %s, %s\", label_buffer, value_buffer);\n  num_fields_in_block += 1;\n  if (num_fields_in_block > max_fields_in_block) {\n    current_state = &Parser::state_error;\n    (this->*(current_state))(c);\n    return;\n  }\n  Field f = {.label = label_buffer, .value = value_buffer};\n  field_list.push_front(f);\n  current_state = &Parser::state_newline;\n  (this->*(current_state))(c);\n}\n\nvoid Parser::state_received_block(char c) {\n  debugD(\"Received block\");\n  for (auto const& field : field_list) {\n    // check if the field is present\n    if (field_parsers.find(field.label) == field_parsers.end()) {\n      // not found, ignore\n      debugD(\"Could not find parser for field %s\", field.label.c_str());\n    } else {\n      // found\n      field_parsers[field.label](field.value);\n    }\n  }\n  field_list.clear();\n  num_fields_in_block = 0;\n  current_state = &Parser::state_newline;\n}\n\nvoid Parser::state_newline(char c) {\n  if (c != 0xd && c != 0xa) {\n    cur_offset = 0;\n    current_state = &Parser::state_label;\n    (this->*(current_state))(c);\n  }\n}\n\nvoid Parser::state_error(char c) {\n  if (c == 0xd || c == 0xa) {\n    num_fields_in_block = 0;\n    field_list.clear();\n    current_state = &Parser::state_newline;\n    (this->*(current_state))(c);\n  }\n}\n\n}  // namespace VEDirect\n"]],"start1":0,"start2":0,"length1":15001,"length2":0}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1734604496024,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Test\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1734606103865}